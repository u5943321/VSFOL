val p31_ex = prove_store("p31_ex",
e0
(rpt strip_tac >> qexists_tac ‘p1(A,B * C)’ >> rw[])
(form_goal
 “!A B C. ?p31: A * B * C ->A. p1(A,B * C) = p31”));

val p31_def = p31_ex |> spec_all |> eqT_intro
                     |> iffRL |> ex2fsym "p31" ["A","B","C"]
                     |> C mp (trueI []) |> gen_all

val p32_ex = prove_store("p32_ex",
e0
(rpt strip_tac >> qexists_tac ‘p1(B,C) o p2(A,B * C)’ >> rw[])
(form_goal
 “!A B C. ?p32: A * B * C ->B.p1(B,C) o p2(A,B * C) = p32”));

val p32_def = p32_ex |> spec_all |> eqT_intro
                     |> iffRL |> ex2fsym "p32" ["A","B","C"]
                     |> C mp (trueI []) |> gen_all

val p33_ex = prove_store("p33_ex",
e0
(rpt strip_tac >> qexists_tac ‘p2(B,C) o p2(A,B * C)’ >> rw[])
(form_goal
 “!A B C. ?p33: A * B * C ->C.p2(B,C) o p2(A,B * C) = p33”));

val p33_def = p33_ex |> spec_all |> eqT_intro
                     |> iffRL |> ex2fsym "p33" ["A","B","C"]
                     |> C mp (trueI []) |> gen_all

                    

val Insert_ex = prove_store("Insert_ex",
e0
(strip_tac >> qexists_tac
 ‘Tp(DISJ o 
    Pa(Eq(X) o Pa(p31(X,X,Exp(X,1+1)),p32(X,X,Exp(X,1+1))),
       Ev(X,1+1) o Pa(p31(X,X,Exp(X,1+1)),p33(X,X,Exp(X,1+1)))))’
 >> rw[])
(form_goal
 “!X.?Ins: X * Exp(X,1+1) -> Exp(X,1+1). 
 Tp(DISJ o 
    Pa(Eq(X) o Pa(p31(X,X,Exp(X,1+1)),p32(X,X,Exp(X,1+1))),
       Ev(X,1+1) o Pa(p31(X,X,Exp(X,1+1)),p33(X,X,Exp(X,1+1))))) = Ins ”));


val Delete_ex = prove_store("Delete_ex",
e0
(strip_tac >> qexists_tac
 ‘Tp(CONJ o 
    Pa(NEG o Eq(X) o Pa(p31(X,X,Exp(X,1+1)),p32(X,X,Exp(X,1+1))),
       Ev(X,1+1) o Pa(p31(X,X,Exp(X,1+1)),p33(X,X,Exp(X,1+1)))))’
 >> rw[])
(form_goal
 “!X.?Del: X * Exp(X,1+1) -> Exp(X,1+1). 
 Tp(CONJ o 
    Pa(NEG o Eq(X) o Pa(p31(X,X,Exp(X,1+1)),p32(X,X,Exp(X,1+1))),
       Ev(X,1+1) o Pa(p31(X,X,Exp(X,1+1)),p33(X,X,Exp(X,1+1))))) = Del ”));


val Insert_def = 
    Insert_ex |> spec_all |> eqT_intro
              |> iffRL |> ex2fsym "Insert" ["X"]
              |> C mp (trueI []) |> gen_all



val Delete_def = 
    Delete_ex |> spec_all |> eqT_intro
              |> iffRL |> ex2fsym "Delete" ["X"]
              |> C mp (trueI []) |> gen_all


val Ins_ex = prove_store("Ins_ex",
e0
(rpt strip_tac >> qexists_tac ‘Insert(X) o Pa(x,s0)’ >> rw[])
(form_goal
“!A X x:A->X s0:A->Exp(X,1+1).?f. Insert(X) o Pa(x,s0) = f”));


val Del_ex = prove_store("Del_ex",
e0
(rpt strip_tac >> qexists_tac ‘Delete(X) o Pa(x,s0)’ >> rw[])
(form_goal
“!A X x:A->X s0:A->Exp(X,1+1).?f. Delete(X) o Pa(x,s0) = f”));



val Ins_def = 
    Ins_ex |> spec_all |> eqT_intro
           |> iffRL |> ex2fsym "Ins" ["x","s0"]
           |> C mp (trueI []) |> gen_all


val Del_def = 
    Del_ex |> spec_all |> eqT_intro
           |> iffRL |> ex2fsym "Del" ["x","s0"]
           |> C mp (trueI []) |> gen_all




val p31_of_Pa = prove_store("p31_of_Pa",
                            e0
                                (rpt strip_tac >> rw[GSYM p31_def,p1_of_Pa] )
                                (form_goal
                                     “!A B C X a:X-> A bc: X-> B * C. p31(A,B,C) o Pa(a, bc) = a”));


val p32_of_Pa = prove_store("p32_of_Pa",
e0
(rpt strip_tac >> rw[GSYM p32_def,o_assoc,p12_of_Pa] )
(form_goal
“!A B C X a:X-> A b: X-> B c: X-> C. p32(A,B,C) o Pa(a, Pa(b,c)) = b”));


val p33_of_Pa = prove_store("p33_of_Pa",
e0
(rpt strip_tac >> rw[GSYM p33_def,o_assoc,p2_of_Pa] )
(form_goal
“!A B C X a:X-> A b: X-> B c: X-> C. p33(A,B,C) o Pa(a, Pa(b,c)) = c”));

val Ins_property = prove_store("Ins_property",
e0
(rpt strip_tac >> rw[GSYM Ins_def,GSYM Insert_def,Ev_of_Tp] >> 
 rw[Ev_of_Tp_el,Pa_distr,o_assoc,DISJ_def,p31_def] >> rw[p31_of_Pa,p32_of_Pa] >> 
(qspecl_then [‘X’,‘1’,‘x’,‘x0’] mp_tac) $ GSYM Eq_property >> once_rw[True1TRUE] >> 
 strip_tac >> arw[] >> rw[p33_of_Pa]
)
(form_goal
 “!X x0:1->X s0:1->Exp(X,1+1).
  !x:1->X. Ev(X,1+1) o Pa(x,Ins(x0,s0)) = TRUE <=> 
  (x = x0 | Ev(X,1+1) o Pa(x,s0) = TRUE)”));




val Pa3_ex = prove_store("Pa3_ex",
e0
(rpt strip_tac >> qexists_tac ‘Pa(f,Pa(g,h))’ >> rw[])
(form_goal
 “!A B C X f:X->A g:X ->B h:X->C. ?Pa3.
 Pa(f,Pa(g,h)) = Pa3 
”));


val Pa3_def = Pa3_ex |> spec_all |> eqT_intro
              |> iffRL |> ex2fsym "Pa3" ["f","g","h"]
              |> C mp (trueI []) |> gen_all

val Pa4_ex = prove_store("Pa4_ex",
e0
(rpt strip_tac >> qexists_tac ‘Pa(f,Pa(g,Pa(h,j)))’ >> rw[])
(form_goal
 “!A B C D X f:X->A g:X ->B h:X->C j:X->D. ?Pa4.
 Pa(f,Pa(g,Pa(h,j))) = Pa4
”));

val Pa4_def = Pa4_ex |> spec_all |> eqT_intro
              |> iffRL |> ex2fsym "Pa4" ["f","g","h","j"]
              |> C mp (trueI []) |> gen_all

val p41_ex = prove_store("p41_ex",
e0
(rpt strip_tac >> qexists_tac ‘p1(A, B * C * D)’ >> rw[])
(form_goal 
 “!A B C D. ?p41. p1(A,B * C * D) = p41”));

val p41_def = p41_ex |> spec_all |> eqT_intro
              |> iffRL |> ex2fsym "p41" ["A","B","C","D"]
              |> C mp (trueI []) |> gen_all

val p42_ex = prove_store("p42_ex",
e0
(rpt strip_tac >> qexists_tac ‘p1(B, C * D) o p2(A,B * C * D)’ >> rw[])
(form_goal 
 “!A B C D. ?p42. p1(B, C * D) o p2(A,B * C * D) = p42”));


val p42_def = p42_ex |> spec_all |> eqT_intro
              |> iffRL |> ex2fsym "p42" ["A","B","C","D"]
              |> C mp (trueI []) |> gen_all


val p43_ex = prove_store("p43_ex",
e0
(rpt strip_tac >> qexists_tac ‘p1(C,D) o p2(B, C * D) o p2(A,B * C * D)’ >> rw[])
(form_goal 
 “!A B C D. ?p43. p1(C,D) o p2(B, C * D) o p2(A,B * C * D) = p43”));


val p43_def = p43_ex |> spec_all |> eqT_intro
              |> iffRL |> ex2fsym "p43" ["A","B","C","D"]
              |> C mp (trueI []) |> gen_all


val p44_ex = prove_store("p44_ex",
e0
(rpt strip_tac >> qexists_tac ‘p2(C,D) o p2(B, C * D) o p2(A,B * C * D)’ >> rw[])
(form_goal 
 “!A B C D. ?p44. p2(C,D) o p2(B, C * D) o p2(A,B * C * D) = p44”));


val p44_def = p44_ex |> spec_all |> eqT_intro
                     |> iffRL |> ex2fsym "p44" ["A","B","C","D"]
                     |> C mp (trueI []) |> gen_all

fun mk_o a1 a2 = mk_fun "o" [a1,a2]

val CONJ = mk_fun "CONJ" []

fun Pa f g = mk_fun "Pa" [f,g]

fun Ex X = mk_fun "Ex" [X]

fun Tp f = mk_fun "Tp" [f]
